## WeChat

* 小程序发展史
	* ​微信官方没有对外暴露过类似浏览图片等微信原生的JS API，此类 API 最初是提供给腾讯内部一些业务使用，很多外部开发者发现了之后，依葫芦画瓢地使用了，逐渐成为微信中网页的事实标准。2015年初，微信发布了一整套网页开发工具包，称之为 JS-SDK，开放了拍摄、录音、语音识别、二维码、地图、支付、分享、卡券等几十个API。让所有开发者都可以使用到微信的原生能力，去完成一些之前做不到或者难以做到的事。
	* JS-SDK 解决了移动网页能力不足的问题，通过暴露微信的接口使得 Web 开发者能够拥有更多的能力，然而在更多的能力之外，JS-SDK 的模式并没有解决使用移动网页遇到的体验不良的问题。用户在访问网页的时候，在浏览器开始显示之前都会有一个白屏的过程，在移动端，受限于设备性能和网络速度，白屏会更加明显。因此设计了一个 JS-SDK 的增强版本，其中有一个重要的功能，称之为“微信 Web 资源离线存储”。这个设计有点类似 HTML5 的 Application Cache，但在设计上规避了一些 Application Cache的不足。在内部测试中发现 离线存储 能够解决一些问题，但对于一些复杂的页面依然会有白屏问题，例如页面加载了大量的 CSS 或者是 JavaScript 文件。​除了白屏，影响 Web 体验的问题还有缺少操作的反馈，主要表现在两个方面：页面切换的生硬和点击的迟滞感。
	* 小程序的由来：一个全新的系统来完成，它需要使得所有的开发者都能做到：
		* 快速的加载
		* 更强大的能力
		* 原生的体验
		* 易用且安全的微信数据开放
		* 高效和简单的开发
* 小程序与普通网页开发的区别
	* 网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。而如上文所述，小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。
* 小程序代码构成
	* .json 后缀的 JSON 配置文件
		* app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等
		* page.json，让开发者可以独立定义每个页面的一些属性
		* 根目录下的 sitemap.json 文件用来配置小程序及其页面是否允许被微信索引
		* 小程序开发者工具在每个项目的根目录都会生成一个 project.config.json，你在工具上做的任何配置都会写入到这个文件，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项
	* .wxml 后缀的 WXML 模板文件
	* WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。
		* WXS 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。
		* WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。
		* WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中不能调用其他 JavaScript 文件中定义的函数，也不能调用小程序提供的API WXS 函数不能作为组件的事件回调
		* 由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。
	* .wxss 后缀的 WXSS 样式文件
		* app.wxss 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 page.wxss 仅对当前页面生效
		* WXSS 仅支持部分 CSS 选择器
	* .js 后缀的 JS 脚本逻辑文件
		* WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端（下文中也会采用Native来代指微信客户端）做中转，逻辑层发送网络请求也经由Native转发
	* behaviors 可以用来让多个页面有相同的数据字段和方法
	* Page 构造器适用于简单的页面。但对于复杂的页面， Page 构造器可能并不好用。可以使用 Component 构造器来构造页面。 Component 构造器的主要区别是：方法需要放在 methods: { } 里面。这种创建方式非常类似于 自定义组件 ，可以像自定义组件一样使用 behaviors 等高级特性
* APPID
	* 小程序ID
* UnionID
	 * 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，UnionID是相同的。
	 * 绑定了开发者帐号的小程序，可以通过以下途径获取 UnionID。
		* 开发者可以直接通过 wx.login + code2Session 获取到该用户 UnionID，无须用户授权。
		* 小程序端调用云函数时，可在云函数中通过 cloud.getWXContext 获取 UnionID。
* OpenID
	* 用户在当前小程序的唯一标识
* session_key 
	* 本次登录的会话密钥
* wx.login，获取用户登录凭证（有效期五分钟）。开发者需要在开发者服务器后台调用 auth.code2Session，使用 code 换取 openid、unionid、session_key 等信息
* 模块化
	* 可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。
		* exports 是 module.exports 的一个引用，因此在模块里边随意更改 exports 的指向会造成未知的错误。所以更推荐开发者采用 module.exports 来暴露模块接口。小程序目前不支持直接引入 node_modules , 开发者需要使用到 node_modules 时候建议拷贝出相关的代码到小程序的目录中，或者使用小程序支持的 npm 功能。			* 使用 require 将公共代码引入
* 组件间通信
	* WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 2.0.9 开始，还可以在数据中包含函数）。具体在 组件模板和样式 章节中介绍。
    * 事件：用于子组件向父组件传递数据，可以传递任意数据。
	* 父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。
	* 默认情况下，小程序与插件之间、不同插件之间的组件将无法通过 selectComponent 得到组件实例（将返回 null），可使用内置 behavior: wx://component-export
* 监听事件
	* 事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。
* 组件数据中的纯数据字段
	* 有些情况下，某些 data 中的字段（包括 setData 设置的字段）既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。此时，可以指定这样的数据字段为“纯数据字段”，它们将仅仅被记录在 this.data 中，而不参与任何界面渲染过程，这样有助于提升页面更新性能。指定“纯数据字段”的方法是在 Component 构造器的 options 定义段中指定 pureDataPattern 为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段。
* 分包加载
		* 在构建小程序分包项目时，构建会输出一个或多个分包。每个使用分包小程序必定含有一个主包。所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本；而分包则是根据开发者的配置进行划分。在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。
		* 目前小程序分包大小有以下限制：
			* 整个小程序所有分包大小不超过 20M
			* 单个分包/主包大小不能超过 2M
			* 对小程序进行分包，可以优化小程序首次启动的下载时间，以及在多团队共同开发时可以更好的解耦协作。
* 页面间通信
	* 如果一个页面由另一个页面通过 wx.navigateTo 打开，这两个页面间将建立一条数据通道：被打开的页面可以通过 this.getOpenerEventChannel() 方法来获得一个 EventChannel 对象；wx.navigateTo 的 success 回调中也包含一个 EventChannel 对象。这两个 EventChannel 对象间可以使用 emit 和 on 方法相互发送、监听事件。




